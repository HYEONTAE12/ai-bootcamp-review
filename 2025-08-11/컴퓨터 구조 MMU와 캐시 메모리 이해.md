
## 컴퓨터 메모리 구조와 데이터 저장 방식 

### 메인 메모리 개요

메인 메모리는 RAM(Random Access Memory)과 ROM(Read-Only Memory)으로 구성됩니다. RAM은 '랜덤 액세스'라는 이름에서 알 수 있듯이 메모리의 어떤 위치에 접근하더라도 동일한 시간이 소요됩니다. 일반적으로 '메모리' 또는 '메인 메모리'라고 할 때는 주로 RAM을 지칭합니다. RAM은 휘발성 저장장치로, 전원이 꺼지면 저장된 내용이 모두 사라집니다.

### RAM의 특성과 종류

RAM의 크기가 클수록 성능이 향상되는 이유는 CPU가 보조기억장치로부터 더 많은 데이터를 미리 메모리에 저장해 둘 수 있기 때문입니다. 이는 마치 작은 책상보다 큰 책상에 더 많은 책을 올려놓고 동시에 읽을 수 있는 것과 같습니다.

RAM의 주요 종류:

- **DRAM(Dynamic RAM)**: 시간이 지나면 저장된 데이터가 점차 사라져 주기적인 재충전이 필요합니다. 가격이 저렴하고 집적도가 높아 대용량으로 설계하기 유리하여 메인 메모리로 주로 사용됩니다.
- **SRAM(Static RAM)**: 전원이 연결되어 있는 한 저장된 데이터가 사라지지 않아 재충전이 필요 없습니다. DRAM보다 빠르지만 비싸고 집적도가 낮아 캐시 메모리에 주로 사용됩니다.
- **SDRAM(Synchronous DRAM)**: 클럭 신호와 동기화되어 있는 DRAM으로, CPU와 정보를 주고받을 때 클럭 타이밍에 맞춰 작동합니다.
- **DDR-SDRAM(Double Data Rate SDRAM)**: SDRAM의 발전된 형태로, 대역폭을 넓혀 속도를 높인 것입니다. 세대별로 DDR2, DDR3, DDR4로 발전하면서 대역폭이 2배씩 증가합니다.

### ROM의 특성과 종류

ROM은 읽기 전용 저장장치로, 한 번 저장하면 그 후에는 읽기만 가능합니다. 비석과 같이 한번 새겨진 내용을 변경할 수 없습니다. 컴퓨터뿐만 아니라 냉장고, 전자레인지, 게임기 등 각종 가전제품에도 사용됩니다.

ROM의 주요 종류:

- **마스크 ROM**: 가장 기본적인 형태로, 제조 과정에서 내용이 기록되어 변경할 수 없습니다.
- **PROM(Programmable ROM)**: 사용자가 한 번 데이터를 기록할 수 있습니다.
- **EPROM(Erasable PROM)**: 데이터를 지우고 다시 저장할 수 있습니다.
    - UV EPROM: 자외선을 이용해 데이터를 지웁니다.
    - EEPROM: 전기 신호를 이용해 데이터를 지웁니다.
- **플래시 메모리**: EEPROM의 발전된 형태로, 오늘날 대부분의 가전제품과 USB 메모리, SD 카드, SSD 등에 사용됩니다.

### 엔디안(Endian) 개념

엔디안은 메모리에 여러 바이트 데이터를 저장할 때의 순서를 의미합니다. 하나의 주소에 1바이트만 저장할 수 있을 때, 4바이트 데이터를 저장하려면 4개 주소에 걸쳐 저장해야 합니다.

- **빅 엔디안(Big-endian)**: 낮은 주소부터 상위 바이트(MSB, Most Significant Byte)를 저장합니다. 일상적인 숫자 읽기 방식과 동일해 디버깅이 편리합니다.
- **리틀 엔디안(Little-endian)**: 낮은 주소부터 하위 바이트(LSB, Least Significant Byte)를 저장합니다. 현대 컴퓨터 시스템에서 많이 사용되며, 계산 시 자리올림이 발생할 때 처리하기 편리합니다.

엔디안이 다른 시스템 간 데이터 교환 시에는 변환이 필요합니다. 네트워크 전송 시에는 대부분 빅 엔디안으로 통일하여 사용합니다. 과거에는 이를 고려하지 않아 "UNIX"가 "NUXI"로 보이는 등의 문제가 발생했습니다.


## 컴퓨터 메모리 주소 체계: 논리주소와 물리주소

### 주소 체계의 중요성

논리주소와 물리주소 개념은 프로그램 실행과 메모리 관리의 핵심입니다. 이 개념은 운영체제 수업에서 페이징 같은 메모리 관리 기법을 배울 때 기본 전제가 되므로 반드시 잘 이해해야 합니다. 이 주소 체계는 실제로 프로그램이 어떤 주소에 접근하는지, 메모리에는 어떻게 저장되는지를 설명합니다.

### 컴퓨터 구조 복습

- 컴퓨터의 4가지 핵심 부품: CPU, 메모리, 보조기억장치, 입출력장치
- 실행 중인 프로그램은 메모리에 적재되어 실행됨
- CPU는 메모리에 접근하여 읽기/쓰기 작업을 수행
- 보조기억장치에 저장된 프로그램은 실행을 위해 메모리로 복사됨

### 논리주소와 물리주소의 차이

- **물리주소(Physical Address)**
    - 실제 메모리 하드웨어상의 주소
    - 고유한 주소 체계 (100번지는 하나만 존재)
    - 메모리가 사용하는 주소 체계
- **논리주소(Logical Address/가상주소/Virtual Address)**
    - CPU와 실행 중인 프로그램이 사용하는 주소
    - 모든 프로그램은 0번지부터 시작하는 자체 논리주소 공간을 가짐
    - 고유하지 않은 주소 체계 (여러 프로그램이 각각 0번지를 가질 수 있음)

### 주소 변환 메커니즘

- 프로그램은 실행될 때마다 다른 메모리 위치에 적재될 수 있음
- 동일한 프로그램을 여러 번 실행하면 서로 다른 물리 메모리 위치에 적재될 수 있음
- CPU와 프로그램이 사용하는 논리주소를 실제 메모리의 물리주소로 변환해야 함
- **MMU(Memory Management Unit)**: 논리주소와 물리주소 간의 변환을 담당하는 장치
    - CPU와 메모리 사이에 위치
    - CPU로부터 논리주소를 받아 해당하는 물리주소로 변환

### 운영체제와의 연결

- 가상 메모리 관리 기법: 실제 물리 메모리보다 큰 프로그램을 실행할 수 있게 해주는 기술
- 현대 운영체제는 대부분 가상 메모리 관리 기법을 지원
- 운영체제 수업에서 페이징 등 메모리 관리 기법을 더 자세히 학습하게 됨
- 컴퓨터 구조와 운영체제는 매우 밀접하게 연관된 과목



# 🖥 MMU, 저장장치 계층 구조, 캐시 메모리 개념 정리

## 1. MMU(Memory Management Unit)의 기본 동작

**MMU**는 CPU가 사용하는 **논리 주소(Logical Address)**를 실제 **물리 주소(Physical Address)**로 변환하는 하드웨어 장치입니다.

### 베이스 레지스터(Base Register)
- **역할**: 현재 실행 중인 프로그램의 **시작 주소(기준 주소)**를 저장
- **주소 변환**:  
  - **논리 주소** = 프로그램 내부에서의 상대적 위치 (offset)  
  - **물리 주소** = 베이스 레지스터 값 + 논리 주소(offset)
- **예시**:
베이스 레지스터: 1000
논리 주소: 120
물리 주소 = 1000 + 120 = 1120


### 한계 레지스터(Limit Register)
- **역할**: 프로그램이 접근할 수 있는 **메모리 범위(크기)**를 지정
- **보호 기능**: CPU가 한계 레지스터 값보다 큰 주소에 접근하려 하면 **메모리 접근 차단** (주소 보호)
- **예시**:
한계 레지스터: 500
논리 주소 600 → 접근 불가 (프로그램 범위 초과)




---

## 2. 저장장치 계층 구조

저장장치는 **CPU와의 거리**에 따라 속도, 용량, 가격이 다릅니다.

| 구분 | 예시 | 속도 | 용량 | 가격 |
|------|------|------|------|------|
| **레지스터** | CPU 내부 | 매우 빠름 | 매우 작음 | 매우 비쌈 |
| **캐시 메모리(L1/L2/L3)** | CPU와 RAM 사이 | 빠름 | 작음 | 비쌈 |
| **메인 메모리(RAM)** | DRAM | 중간 | 중간 | 중간 |
| **보조 기억장치** | SSD, HDD | 느림 | 큼 | 저렴 |
| **원격 저장** | 클라우드 스토리지 | 매우 느림 | 매우 큼 | 사용량 기반 과금 |

**특징**:
1. **CPU에 가까울수록** 속도가 빠르지만 용량이 작고 가격이 비쌈.
2. **멀어질수록** 속도가 느리고 용량은 크며 가격이 저렴.

---

## 3. 캐시 메모리(Cache Memory)

### 개념
- **목적**: CPU와 메모리 간 **속도 차이**를 줄이기 위해 도입
- **위치**: CPU와 메모리(RAM) 사이
- **구조**: SRAM 기반, 레지스터보다 용량 크고 RAM보다 빠름
- **역할**: CPU가 곧 사용할 가능성이 높은 데이터를 **미리 가져와 저장**

> 메모리가 대형 마트라면, 캐시 메모리는 집 근처 편의점 같은 역할  
> → 자주 쓰는 물건은 편의점(캐시)에서 바로 가져옴

---

## 4. 캐시 동작

### 캐시 히트(Cache Hit)
- CPU가 필요한 데이터가 **캐시 메모리**에 있는 경우
- 메모리 접근 없이 즉시 사용 가능 → 속도 향상

### 캐시 미스(Cache Miss)
- CPU가 필요한 데이터가 **캐시 메모리**에 없는 경우
- 메인 메모리에서 가져와 캐시에 적재한 후 사용

---

## 5. 지역성의 원리(Locality)

**프로그램의 데이터 접근 패턴**을 활용해 캐시 효율을 높이는 원리

### 시간 지역성(Temporal Locality)
- **최근 사용한 데이터**는 곧 다시 사용될 가능성이 높음
- 예시: 반복문에서 같은 변수를 여러 번 참조

### 공간 지역성(Spatial Locality)
- **특정 데이터 근처의 데이터**도 곧 사용될 가능성이 높음
- 예시: 배열 요소를 순차적으로 접근

---

## 6. 캐시 친화적 코드(Cache-friendly Code)

**목표**: 캐시 미스를 최소화하여 성능을 높이는 코드 작성

### 원칙
1. **연속적인 메모리 접근**: 배열·리스트를 순차적으로 접근
2. **자주 쓰는 데이터는 묶어서**: 구조체·클래스에서 접근 패턴 고려
3. **반복문 최적화**: 같은 데이터 참조를 최대한 묶어 사용
4. **데이터 크기 최적화**: 불필요하게 큰 자료형 사용 자제

### 예시 (파이썬)

# 캐시 친화적: 순차 접근
arr = [i for i in range(1000000)]

for i in arr:  

  pass

# 캐시 비효율적: 랜덤 접근
**import random**

indices = list(range(len(arr)))

random.shuffle(indices)

for i in indices:

  _ = arr[i]


## 📌 요약
**MMU: 논리 주소를 물리 주소로 변환 (베이스 레지스터 + 한계 레지스터로 보호)**

**저장장치 계층: 가까울수록 빠르고 작고 비싸다**

**캐시 메모리: CPU-메모리 속도 차 완화, SRAM 기반**

**지역성 원리: 시간·공간 지역성을 이용해 캐시 효율 향상**

**캐시 친화적 코드: 캐시 미스 최소화 = 성능 향상**
