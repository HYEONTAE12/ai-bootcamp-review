## 컴퓨터 구조론 강의: 데이터 표현과 인코딩 

### 데이터와 명령어 개념

- 데이터: 컴퓨터가 이해하는 숫자, 문자, 이미지 등 정적 정보
- 명령어: 데이터를 움직이고 컴퓨터를 작동시키는 정보
- 컴퓨터 프로그램은 명령어들의 모임

### 컴퓨터 정보 표현 단위

- 비트(bit): 컴퓨터가 표현할 수 있는 가장 작은 정보 단위 (0 또는 1)
- n비트로 표현 가능한 정보량: 2ⁿ개
- 바이트(byte): 8비트 = 1바이트 (데이터의 기본 단위)
- 단위 체계: KB(킬로바이트), MB(메가바이트), GB(기가바이트), TB(테라바이트)
- 정확한 단위: 1KiB = 2¹⁰ = 1024바이트 (vs 1KB = 1000바이트)

### 숫자 표현 체계

- 이진법(2진법): 0과 1만 사용하는 표기법
- 십진법 → 이진법 변환 방법: 2로 계속 나누어 나머지를 기록
- 16진법: 0-9와 A-F 사용 (A=10, B=11, ..., F=15)
- 16진법 표기: 앞에 0x 붙임 (예: 0x1A)
- 16진법의 장점: 이진법과 변환이 용이하고 메모리 효율적

### 문자 인코딩

- 문자집합: 컴퓨터가 인식하고 표현할 수 있는 문자들의 모음
- 인코딩: 사람이 알아보는 문자를 컴퓨터가 이해할 수 있는 숫자로 변환
- 디코딩: 컴퓨터의 숫자 표현을 사람이 알아볼 수 있는 문자로 변환

### ASCII 코드

- 7비트로 128개 문자 표현 (영어, 숫자, 일부 특수문자)
- 알고리즘 테스트에 유용한 정보: 대문자 A는 65, 소문자 a는 97
- 한계: 영어 외 다른 언어 표현 불가

### 한글 인코딩

- 조합형 방식: 초성, 중성, 종성을 각각 인코딩 (3바이트 필요)
- 완성형 방식: 완성된 글자 하나를 하나의 코드로 표현 (2바이트)
- EUC-KR: 2바이트로 2,350개 한글 문자 표현
- CP949: EUC-KR의 확장 버전으로 더 많은 한글 표현 가능

## Project Sync / Status Update — 확장 요약

## 1. 핵심 주제 개요 (보강판)

- **유니코드와 UTF-8 인코딩 원리**
    - 전 세계 모든 문자를 하나의 코드 체계(U+XXXX)로 통일
    - UTF-8: 1~4바이트 가변 길이, ASCII와 호환, 웹 표준
- **EUC-KR, CP949 한계**
    - EUC-KR: 약 2,350자 한글 지원 → 옛한글·확장 문자 표현 불가
    - CP949: MS 확장, 11,172자 한글 표현 가능하지만 다국어에는 미흡
- **UTF-8에서 한글 처리**
    - 한글은 주로 3바이트 사용(0x0800–0xFFFF 영역)
    - 변환 규칙과 비트 배치 이해 필요
- **인코딩 불일치 문제**
    - 깨짐(�) 원인: 서로 다른 인코딩 간 해석 불일치
    - 예방: 시스템 전 구간 동일 인코딩 유지
- **언어 실행 메커니즘**
    - 고급 언어 → 저급 언어 변환: 컴파일러(전체 변환) vs 인터프리터(실시간 해석)
    - 목적 코드 생성, 성능·개발 편의성 비교
- **링킹(Linking)**
    - 목적 코드와 라이브러리 결합, 실행 가능 바이너리 생성
    - 정적/동적 링킹, 의존성 관리 필요
- **컴퓨터 구조**
    - CPU(제어장치·ALU·레지스터), 메모리(램/롬), 보조기억장치, 입출력장치, 시스템 버스
    - 클럭, 코어·멀티코어, 성능 병목 요소 이해
- **실무 팁**
    - 램 접점 청소, 모듈 재장착 등 기본 점검 방법 포함

---

## 2. 유니코드/인코딩 상태 업데이트

**문제 인식**

- EUC-KR/CP949 → 표준성 부족, 국제화 제한
- 국가별 인코딩 혼재 → 운영·개발 복잡성 증가

**표준 방향**

- **유니코드(Unicode)**: 전 세계 문자 코드 통합 (U+XXXX)
- **UTF-8**: 웹·시스템 표준, ASCII 호환, 바이트 절약 가능

**코드 포인트별 바이트 규칙**

- 0000–007F → 1B
- 0080–07FF → 2B
- 0800–FFFF → 3B
- 10000–10FFFF → 4B

**운영 시사점**

- EUC-KR → UTF-8 변환 가능
- CP949 ↔ UTF-8 일부 변환 가능
- UTF-8 → EUC-KR 변환 시 손실 가능성
- 서비스 전 구간 UTF-8 일관성 유지 필수 (DB·파일·HTTP 헤더·HTML 메타 등)

---

## 3. 언어 실행 메커니즘

**고급 언어**

- 사람이 읽기 좋은 문법 (C/C++, Java, Python 등)

**저급 언어**

- 기계어·어셈블리 — 하드웨어가 직접 실행 가능

**변환 방식**

- **컴파일**: 전체 변환 → 목적 코드(실행 파일)
    
    장점: 빠른 실행, 최적화 가능
    
    단점: 수정 후 재컴파일 필요
    
- **인터프리트**: 한 줄씩 해석 실행
    
    장점: 즉시 실행, 대화형 개발
    
    단점: 실행 속도 느림
    

**링킹**

- **정적 링킹**: 실행 파일에 모든 코드 포함
- **동적 링킹**: 실행 시 외부 라이브러리 로드
- 다중 모듈·공용 라이브러리 활용 시 필수 과정

---

## 4. 컴퓨터 구조 및 성능

**구성 요소**

- CPU: 명령 인출-해독-실행
- CU: 제어 신호로 전체 흐름 관리
- ALU: 연산 처리
- 레지스터: 초고속 임시 저장
- 메모리(램): 실행 중 데이터·코드 저장 (휘발성)
- 롬: 읽기 전용, 펌웨어 저장 (비휘발성)
- 보조기억장치: HDD/SSD
- 입출력장치: 키보드, 모니터 등
- 시스템 버스: 데이터·주소·제어 전송

**성능 요소**

- 클럭: 주파수(Hz), 터보 부스트
- 코어/멀티코어: 병렬 처리 가능성
- 병목 요소: 메모리 대역폭, I/O 속도

**실무 팁**

- 램 접점 청소, 모듈 재장착 → 부팅 문제 해결 가능

---

## 5. 리스크 및 결정 사항

**결정**

- 전사 인코딩 표준: UTF-8

**리스크**

- 레거시 데이터 변환 시 손실 가능
- DB/API 경계에서 인코딩 불일치 위험

**대응**

- 전 구간 인코딩 명시
- 변환 시 손실 감지·대체 문자 정책 적용

---

## 6. 다음 단계 제안

- **인코딩 표준화**
    - 소스·빌드·배포·서버·응답·HTML 메타 모두 UTF-8
    - DB 문자셋·콜레이션 UTF-8로 변경
- **검증**
    - 한글+다국어 포함 테스트 케이스
    - 인코딩 검출 룰 로깅·모니터링 적용
- **문서화**
    - 코딩 규약에 인코딩 정책 반영
    - 팀원 교육 및 가이드 배포

**추가 보충**

- **링킹**은 실행 파일 생성 시 필수 단계이며, 특히 대규모 프로젝트나 모듈형 아키텍처에서 중요
- **인코딩 전환** 시, CSV·JSON·XML 등 파일 포맷별 BOM(Byte Order Mark) 여부도 점검 필요
- **멀티코어 활용**은 OS 스케줄러·스레드 설계와 밀접, 단순 코어 증가가 곧 성능 향상은 아님

## 컴퓨터 메모리 아키텍처와 저장 시스템 강의

### CPU와 메모리 상호작용

- CPU는 보조기억장치에 직접 접근할 수 없어 RAM을 통해 데이터를 처리
- 실행할 프로그램은 보조기억장치에서 RAM으로 복사된 후 CPU가 접근
- RAM 용량이 적으면 프로그램 교체 작업이 잦아져 실행 시간 증가
- RAM 용량이 크면 여러 프로그램을 동시에 실행하는데 유리함
- 필요 이상의 RAM 용량은 성능 향상에 큰 영향 없음
- 8GB 메모리 2개(듀얼 채널)가 16GB 1개(단일 채널)보다 효율적

### 저장장치 계층구조

- CPU와 가까울수록 빠르고 용량이 적으며 가격이 비싼 구조
- 계층 순서: 레지스터 > L1 캐시 > L2 캐시 > L3 캐시 > RAM > 보조기억장치
- 레지스터: CPU 내부에 위치, 가장 빠르나 용량 매우 적음
- 레지스터 종류: 메모리 레지스터, 프로그램 카운터, 스택 주소 저장 등 다양한 기능

### 캐시 메모리 시스템

- CPU와 메모리 간 속도 차이를 줄이기 위한 중간 저장장치
- L1 캐시: CPU 코어 내부에 위치, 명령어(L1I)와 데이터(L1D)로 분리(하버드 캐시)
- L2 캐시: 코어 내부에 위치, L1보다 용량 크고 속도 느림
- L3 캐시: 여러 코어가 공유하는 대용량 캐시
- 현대 CPU는 전체 칩 면적의 30-70%가 캐시 메모리
- 멀티코어 CPU에서는 L3 캐시를 여러 코어가 공유

### 메모리 관리(가상 주소와 물리 주소)

- CPU와 프로그램은 가상 주소 사용, 실제 메모리는 물리 주소 사용
- 가상 주소: 각 프로그램에 할당된 0번지부터 시작하는 논리적 주소
- 물리 주소: 실제 하드웨어 메모리의 위치를 나타내는 주소
- MMU(Memory Management Unit)가 가상 주소를 물리 주소로 변환
- 베이스 레지스터 값을 논리 주소에 더해 물리 주소 계산

### RAID 저장 시스템

- 여러 개의 물리적 저장장치를 하나의 논리적 장치처럼 사용
- RAID 0(스트라이핑): 데이터를 여러 디스크에 분산 저장, 속도 향상되나 안정성 낮음
- RAID 1(미러링): 데이터 복사본을 만들어 안정성 확보, 용량 효율성 낮음
- RAID 4: 패리티 정보를 별도 디스크에 저장하여 오류 복구 가능
- RAID 5: 패리티 정보를 모든 디스크에 분산 저장
- RAID 6: 이중 패리티로 더 높은 안정성 제공, 쓰기 속도는 느림

### 하드웨어 캐시 vs 레디스(Redis)

- 캐시 메모리: CPU를 위한 하드웨어 캐시, 자동으로 작동
- 레디스: 웹서비스를 위한 소프트웨어 캐시, 수동 설정 필요
- 공통점: 자주 사용하는 데이터를 가까운 곳에 두어 접근 속도 향상
- 캐시 메모리: 수십 KB~수 MB 크기, 제어 불가능
- 레디스: 수 GB~수십 GB 크기, 사용자가 데이터 관리 가능

## 컴퓨터 아키텍처와 처리 기술 강의

### 시스템 버스와 통신

- 주소버스는 기억장치의 최대 용량을 결정
- 버스는 CPU, 메모리, 저장장치 등 각 부품 간 데이터 이동 통로 역할
- 버스 속도와 대역폭이 전체 시스템 성능에 영향
- 컴퓨터 내부 구성요소 간 양방향 통신 수행

### CPU 구조와 기능

- CPU(Central Processing Unit)는 컴퓨터의 두뇌 역할
- 구성요소: ALU(산술논리장치), 컨트롤유닛, 레지스터
- ALU는 산술연산(덧셈, 뺄셈, 곱셈, 나눗셈)과 논리연산(AND, OR, NOT) 수행
- 논리연산 원리:
    - AND: 두 값 모두 TRUE일 때만 TRUE (둘 다 만족해야 1)
    - OR: 하나라도 TRUE이면 TRUE (하나만 만족해도 1)

### 메모리와 저장장치

- RAM: CPU가 당장 처리할 프로그램을 올려두는 임시 저장소
    - 휘발성: 전원이 꺼지면 데이터 소실
    - CPU와 직접 통신하며 빠른 접근 가능
- 캐시: RAM과 CPU 사이에 위치, 빈번하게 사용하는 데이터 저장
- 보조기억장치(HDD, SSD): 영구적으로 데이터 저장
    - SSD는 HDD보다 속도 빠르지만 가격 비쌈
    - 예: 윈도우 부팅 속도 향상을 위해 SSD 사용 권장
- 파이썬 예제: 메모리에 데이터 저장 및 파일 입출력 구현

### 폰노이만 아키텍처

- 현대 컴퓨터 설계의 기반이 되는 모델
- 핵심 특징: 프로그램과 데이터가 동일한 메모리 공간에 저장
- CPU 작동 사이클: 명령어 인출(fetch), 해석(decode), 실행(execute)
- 장점: 구조 간단, 프로그램 변경 용이
- 단점: 병목 현상 발생 (CPU와 메모리가 동일한 버스 사용)
- 현대 컴퓨터는 캐시 메모리, 명령어 파이프라인 등으로 병목 현상 완화

### CPU vs GPU와 AI 응용

- CPU: 소수의 고성능 코어, 복잡한 명령어 처리, 순차적 작업에 최적화
- GPU: 수백개의 단순한 코어, 병렬 처리에 최적화
- AI와 딥러닝은 대규모 행렬 연산이 필요하여 GPU가 효과적
    - CPU로 처리 시 7-8시간 걸리는 작업이 GPU로는 1시간 이내로 단축
- 텐서플로우 같은 라이브러리로 GPU 병렬 처리 활용 가능
- 이미지 처리, 신경망 가중치 업데이트 등 AI 작업에 GPU가 유리
