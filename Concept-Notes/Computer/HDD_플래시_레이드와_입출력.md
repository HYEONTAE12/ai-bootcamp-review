# 하드 디스크와 플래시 메모리 (정리 + 보충)

> 보조기억장치 전반, RAID 레벨, I/O(프로그램/인터럽트/DMA), DMA 세부(사이클 스틸링·입출력 버스·입출력 채널)까지 **원문 전부 포함** + **핵심 보충**.

## 1) 대표적인 보조기억장치 개요

* **HDD(하드 디스크 드라이브)**: 회전하는 매체 + 기계식 헤드(동작 원리 측면에서 **LP, CD/DVD 플레이어와 유사**)
* **플래시 메모리**: 반도체 기반 저장장치(SSD, USB, SD 카드 등) — **비휘발성**, 충격에 강하고 속도/병렬성 유리

---

## 2) 하드 디스크(HDD)

### 2-1. 구성요소

* **플래터(Platter)**: 자성 물질 코팅된 원형 디스크, **데이터가 실제로 저장**되는 면
* **스핀들(Spindle)**: 플래터를 **정속 회전**시키는 축·모터
* **헤드(Head)**: 플래터 위 데이터를 **읽고/쓰기**하는 자성 헤드
* **디스크 암(Disk Arm)**: 헤드를 **반경 방향**으로 이동시키는 부품(보이스 코일 액추에이터)
* **특성**: **충돌에 민감**(헤드가 표면에 닿는 **헤드 크래시** 위험), 충격 취약

### 2-2. 데이터 단위(주소 체계)

* **트랙(Track)**: 플래터 표면의 **동심원**
* **섹터(Sector)**: 트랙을 분할한 **최소 주소 단위**
* **실린더(Cylinder)**: 여러 플래터에 걸쳐 **같은 반경**의 트랙 집합
* **블록(Block)**: **실제 I/O가 수행되는 단위**(여러 섹터 묶음; OS/파일시스템 관점)

### 2-3. 지연 시간 구성

* **탐색 시간(Seek Time)**: 헤드를 **목표 트랙**까지 이동
* **회전 지연(Rotational Latency)**: **목표 섹터**가 헤드 아래로 **돌아올 때까지** 대기
  (평균 회전 지연 ≈ 1/2 회전주기)
* **전송 시간(Transfer Time)**: **데이터를 송수신**하는 실제 전송 구간
* **총 접근 시간 ≈ 탐색 + 회전 지연 + 전송**

---

## 3) 플래시 메모리

### 3-1. 종류

* **NOR 플래시**: **바이트/워드 단위 랜덤 접근** 용이, 코드 실행에 유리(임베디드에서 부트로더 등)
* **NAND 플래시**: **페이지 단위 I/O**, **고집적·저비용**, 대용량 **SSD/메모리카드**의 주류
---

# 📘 NOR Flash vs NAND Flash 정리

## 1. NOR Flash 특징

* **구조**: 셀이 병렬(NOR 게이트처럼) 연결 → 원하는 주소(바이트/워드)에 바로 접근 가능.
* **접근 단위**: 바이트/워드 단위 랜덤 접근 가능.
* **장점**

  * **XIP (Execute In Place)** 가능 → 플래시에서 직접 코드 실행.
  * 빠른 읽기 속도, 랜덤 접근 성능 우수.
  * 코드 실행(부트로더, 펌웨어, BIOS)에 적합.
* **단점**

  * 쓰기/지우기 속도 느림.
  * 집적도가 낮아 용량이 작고 가격이 비쌈 (수 MB\~수십 MB 수준).

---

## 2. NAND Flash 특징

* **구조**: 셀이 직렬(NAND 게이트처럼) 연결 → 집적도 높음.
* **접근 단위**: 페이지 단위(2KB\~16KB)로만 읽고 씀.
* **장점**

  * **고집적·저비용** → GB\~TB 대용량 가능.
  * 쓰기/지우기 속도가 NOR보다 빠름.
  * SSD, USB, 스마트폰, SD 카드 등 대용량 저장의 주류.
* **단점**

  * 바이트 단위 랜덤 접근 불가, XIP 불가능.
  * ECC(Error Correcting Code) 필요 → 신뢰성 관리 필수.
  * 컨트롤러와 캐시로 성능 보정 필요.

---

## 3. MCU, 부트로더, XIP

* **MCU (Microcontroller Unit)**

  * CPU + RAM + 플래시 + I/O가 하나의 칩에 들어간 작은 컴퓨터.
  * IoT 기기, 자동차 ECU, 가전제품 등에서 사용.

* **부트로더 (Bootloader)**

  * 전원이 켜졌을 때 가장 먼저 실행되는 작은 프로그램.
  * 하드웨어 초기화 및 운영체제/펌웨어 로딩 담당.

* **XIP (Execute In Place)**

  * RAM에 복사하지 않고 플래시에서 직접 코드 실행.
  * NOR은 바이트/워드 단위 접근이 가능해서 XIP 지원.
  * NAND는 페이지 단위 접근만 가능해서 XIP 불가 → 코드 실행 전 반드시 RAM으로 복사해야 함.

---

## 4. 용도 차이

* **NOR Flash**

  * 소규모 코드 저장 & 직접 실행이 필요한 곳.
  * 예: 부트로더, 펌웨어, BIOS, MCU 코드.

* **NAND Flash**

  * 대용량 데이터 저장에 적합.
  * 예: SSD, 스마트폰 저장소, USB, 메모리 카드.

---

## 5. 질문 & 답변 요약

### Q: **페이지 단위 접근이 뭐야?**

* NAND는 작은 바이트 하나만 읽으려 해도, 해당 바이트가 속한 \*\*전체 페이지(2KB\~16KB)\*\*를 통째로 읽어와야 함.
* 반면 NOR은 원하는 주소 하나만 딱 읽을 수 있음 → 코드 실행에 유리.

---

### Q: **왜 MCU에는 NOR이 적합할까?**

* MCU는 RAM이 작거나 없어서, 프로그램을 플래시에서 직접 실행해야 함.
* NOR은 **XIP 지원 + 랜덤 접근 우수 + 신뢰성 높음** → 펌웨어 저장에 적합.
* NAND는 대용량이 장점이지만, 코드 실행용으로는 불리.

---

### Q: **스마트폰에는 왜 NAND가 유리할까?**

* 스마트폰은 수 GB\~TB의 대용량 저장이 필요.
* NOR은 작은 코드 실행에는 좋지만, 대용량 저장은 비효율적.
* NAND는 고집적/저비용 구조라서 사진, 동영상, 앱 등 저장에 최적.
* 부트로더 같은 초기 실행 코드만 소형 NOR/ROM에 두고, 운영체제와 데이터는 NAND에 저장.

---

✅ 요약

* **NOR**: “작고 빠른 코드 실행용” (MCU, 부트로더).
* **NAND**: “싸고 큰 데이터 저장용” (스마트폰, SSD).

---

### 3-2. 저장/삭제 단위와 계층

* **셀(Cell)**: 플로팅 게이트(또는 차지 트랩)에 **전하를 축적**하여 정보 저장(가장 작은 저장 단위)
* **페이지(Page)**: 여러 셀의 **읽기/쓰기 단위**
* **블록(Block)**: 여러 페이지의 **삭제 단위**
* **플레인(Plane)**: 여러 블록의 모임(내부 병렬성 단위)
* **다이(Die)**: 여러 플레인의 모임(하나의 실리콘 칩)

> **읽기/쓰기 = 페이지 단위**, **삭제 = 블록 단위**
> 플래시는 **Erase-before-Write 제약**이 있어, 덮어쓰기 대신 **새 페이지에 기록→가비지 컬렉션**으로 정리.
> 수명 이슈 대응을 위해 **웨어 레벨링(Wear-Leveling)**, \*\*FTL(Flash Translation Layer)\*\*로 논리주소↔물리주소 매핑.

### 3-3. 셀 타입(한 셀에 저장 가능한 비트 수)

| 타입           | 비트/셀 | 속도     | 내구성(수명) | 비용/용량 특성      |
| ------------ | ---: | ------ | ------- | ------------- |
| **SLC**      |    1 | 매우 빠름  | 매우 김    | 비쌈 / 용량 낮음    |
| **MLC**      |    2 | 보통     | SLC↓    | 비용↓ / 용량↑     |
| **TLC**      |    3 | 느림     | MLC↓    | 비용↓↓ / 용량↑↑   |
| **QLC**      |    4 | 더 느림   | 가장 짧음   | 비용↓↓↓ / 용량↑↑↑ |
| (참고) **PLC** |    5 | 연구/제한적 | —       | —             |

---

## 4) RAID 레벨

> **RAID(Independent Disks)**: 여러 디스크를 논리적으로 묶어 **성능/신뢰성/용량**을 조절

### 4-1. 요약 표

| 레벨          | 개념                | 최소 디스크 |    고장 허용 | 용량 효율(대략) | 특성 키워드     |
| ----------- | ----------------- | -----: | -------: | --------- | ---------- |
| **RAID 0**  | 스트라이핑             |      2 |       0개 | 100%      | 성능↑, 신뢰성↓  |
| **RAID 1**  | 미러링               |      2 |  1개(쌍마다) | 50%       | 복구 용이, 쓰기↓ |
| **RAID 2**  | 해밍 코드             |     ≥3 |   ECC 기반 | 낮음        | 실사용 드묾     |
| **RAID 3**  | 전용 패리티(바이트/블록)    |     ≥3 |       1개 | (N-1)/N   | 순차성능↑, 병목  |
| **RAID 4**  | 전용 패리티(디스크)       |     ≥3 |       1개 | (N-1)/N   | 패리티 디스크 병목 |
| **RAID 5**  | **분산 패리티**        |     ≥3 |       1개 | (N-1)/N   | 실무 표준, 균형  |
| **RAID 6**  | **이중 패리티**        |     ≥4 |       2개 | (N-2)/N   | 신뢰성↑, 쓰기↓  |
| **RAID 10** | 1+0(미러 후 스트라이프)   |     ≥4 | 각 미러당 1개 | 50%       | 성능·복구 모두↑  |
| **RAID 50** | 5+0(스트라이프의 RAID5) |     ≥6 |   그룹당 1개 | >RAID10   | 대용량·성능 균형  |

---

## 5) CPU와 I/O 장치 간 데이터 교환

### 5-1. 까다로운 이유

1. 장치 종류 다양
2. CPU와 I/O 장치 속도 차 큼

### 5-2. 구성요소

* **장치 컨트롤러**: CPU↔장치 통신, 오류검출, 버퍼링
* **장치 드라이버**: OS 커널 모듈로 컨트롤러 동작 제어

### 5-3. I/O 방식

1. **Programmed I/O (Polling)** – CPU가 상태 확인, 비효율적
2. **Interrupt-driven I/O** – 장치가 인터럽트로 CPU 호출, 효율적
3. **DMA(Direct Memory Access)** – CPU 거치지 않고 메모리↔장치 직접 전송, DMA 컨트롤러 필요

---

## 6) DMA 심화

* **사이클 스틸링**: DMA가 CPU 버스 사이클을 빼앗아 전송 → CPU 성능 일시저하
* **버스트 모드**: 한 번 버스를 잡고 블록 전송 → 효율↑, CPU 대기↑
* **I/O 전용 버스**: 시스템 버스 사용 최소화
* **입출력 채널**: I/O 전용 프로세서, 명령 해석·실행 전담

---

