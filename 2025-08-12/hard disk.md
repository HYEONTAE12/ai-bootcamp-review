# 하드 디스크와 플래시 메모리 (정리 + 보충)

> 보조기억장치 전반, RAID 레벨, I/O(프로그램/인터럽트/DMA), DMA 세부(사이클 스틸링·입출력 버스·입출력 채널)까지 **원문 전부 포함** + **핵심 보충**.

## 1) 대표적인 보조기억장치 개요

* **HDD(하드 디스크 드라이브)**: 회전하는 매체 + 기계식 헤드(동작 원리 측면에서 **LP, CD/DVD 플레이어와 유사**)
* **플래시 메모리**: 반도체 기반 저장장치(SSD, USB, SD 카드 등) — **비휘발성**, 충격에 강하고 속도/병렬성 유리

---

## 2) 하드 디스크(HDD)

### 2-1. 구성요소

* **플래터(Platter)**: 자성 물질 코팅된 원형 디스크, **데이터가 실제로 저장**되는 면
* **스핀들(Spindle)**: 플래터를 **정속 회전**시키는 축·모터
* **헤드(Head)**: 플래터 위 데이터를 **읽고/쓰기**하는 자성 헤드
* **디스크 암(Disk Arm)**: 헤드를 **반경 방향**으로 이동시키는 부품(보이스 코일 액추에이터)
* **특성**: **충돌에 민감**(헤드가 표면에 닿는 **헤드 크래시** 위험), 충격 취약

### 2-2. 데이터 단위(주소 체계)

* **트랙(Track)**: 플래터 표면의 **동심원**
* **섹터(Sector)**: 트랙을 분할한 **최소 주소 단위**
* **실린더(Cylinder)**: 여러 플래터에 걸쳐 **같은 반경**의 트랙 집합
* **블록(Block)**: **실제 I/O가 수행되는 단위**(여러 섹터 묶음; OS/파일시스템 관점)

### 2-3. 지연 시간 구성

* **탐색 시간(Seek Time)**: 헤드를 **목표 트랙**까지 이동
* **회전 지연(Rotational Latency)**: **목표 섹터**가 헤드 아래로 **돌아올 때까지** 대기
  (평균 회전 지연 ≈ 1/2 회전주기)
* **전송 시간(Transfer Time)**: **데이터를 송수신**하는 실제 전송 구간
* **총 접근 시간 ≈ 탐색 + 회전 지연 + 전송**

---

## 3) 플래시 메모리

### 3-1. 종류

* **NOR 플래시**: **바이트/워드 단위 랜덤 접근** 용이, 코드 실행에 유리(임베디드에서 부트로더 등)
* **NAND 플래시**: **페이지 단위 I/O**, **고집적·저비용**, 대용량 **SSD/메모리카드**의 주류

### 3-2. 저장/삭제 단위와 계층

* **셀(Cell)**: 플로팅 게이트(또는 차지 트랩)에 **전하를 축적**하여 정보 저장(가장 작은 저장 단위)
* **페이지(Page)**: 여러 셀의 **읽기/쓰기 단위**
* **블록(Block)**: 여러 페이지의 **삭제 단위**
* **플레인(Plane)**: 여러 블록의 모임(내부 병렬성 단위)
* **다이(Die)**: 여러 플레인의 모임(하나의 실리콘 칩)

> **읽기/쓰기 = 페이지 단위**, **삭제 = 블록 단위**
> 플래시는 **Erase-before-Write 제약**이 있어, 덮어쓰기 대신 **새 페이지에 기록→가비지 컬렉션**으로 정리.
> 수명 이슈 대응을 위해 **웨어 레벨링(Wear-Leveling)**, \*\*FTL(Flash Translation Layer)\*\*로 논리주소↔물리주소 매핑.

### 3-3. 셀 타입(한 셀에 저장 가능한 비트 수)

| 타입           | 비트/셀 | 속도     | 내구성(수명) | 비용/용량 특성      |
| ------------ | ---: | ------ | ------- | ------------- |
| **SLC**      |    1 | 매우 빠름  | 매우 김    | 비쌈 / 용량 낮음    |
| **MLC**      |    2 | 보통     | SLC↓    | 비용↓ / 용량↑     |
| **TLC**      |    3 | 느림     | MLC↓    | 비용↓↓ / 용량↑↑   |
| **QLC**      |    4 | 더 느림   | 가장 짧음   | 비용↓↓↓ / 용량↑↑↑ |
| (참고) **PLC** |    5 | 연구/제한적 | —       | —             |

---

## 4) RAID 레벨

> **RAID(Independent Disks)**: 여러 디스크를 논리적으로 묶어 **성능/신뢰성/용량**을 조절

### 4-1. 요약 표

| 레벨          | 개념                | 최소 디스크 |    고장 허용 | 용량 효율(대략) | 특성 키워드     |
| ----------- | ----------------- | -----: | -------: | --------- | ---------- |
| **RAID 0**  | 스트라이핑             |      2 |       0개 | 100%      | 성능↑, 신뢰성↓  |
| **RAID 1**  | 미러링               |      2 |  1개(쌍마다) | 50%       | 복구 용이, 쓰기↓ |
| **RAID 2**  | 해밍 코드             |     ≥3 |   ECC 기반 | 낮음        | 실사용 드묾     |
| **RAID 3**  | 전용 패리티(바이트/블록)    |     ≥3 |       1개 | (N-1)/N   | 순차성능↑, 병목  |
| **RAID 4**  | 전용 패리티(디스크)       |     ≥3 |       1개 | (N-1)/N   | 패리티 디스크 병목 |
| **RAID 5**  | **분산 패리티**        |     ≥3 |       1개 | (N-1)/N   | 실무 표준, 균형  |
| **RAID 6**  | **이중 패리티**        |     ≥4 |       2개 | (N-2)/N   | 신뢰성↑, 쓰기↓  |
| **RAID 10** | 1+0(미러 후 스트라이프)   |     ≥4 | 각 미러당 1개 | 50%       | 성능·복구 모두↑  |
| **RAID 50** | 5+0(스트라이프의 RAID5) |     ≥6 |   그룹당 1개 | >RAID10   | 대용량·성능 균형  |

---

## 5) CPU와 I/O 장치 간 데이터 교환

### 5-1. 까다로운 이유

1. 장치 종류 다양
2. CPU와 I/O 장치 속도 차 큼

### 5-2. 구성요소

* **장치 컨트롤러**: CPU↔장치 통신, 오류검출, 버퍼링
* **장치 드라이버**: OS 커널 모듈로 컨트롤러 동작 제어

### 5-3. I/O 방식

1. **Programmed I/O (Polling)** – CPU가 상태 확인, 비효율적
2. **Interrupt-driven I/O** – 장치가 인터럽트로 CPU 호출, 효율적
3. **DMA(Direct Memory Access)** – CPU 거치지 않고 메모리↔장치 직접 전송, DMA 컨트롤러 필요

---

## 6) DMA 심화

* **사이클 스틸링**: DMA가 CPU 버스 사이클을 빼앗아 전송 → CPU 성능 일시저하
* **버스트 모드**: 한 번 버스를 잡고 블록 전송 → 효율↑, CPU 대기↑
* **I/O 전용 버스**: 시스템 버스 사용 최소화
* **입출력 채널**: I/O 전용 프로세서, 명령 해석·실행 전담

---

이걸 그대로 붙여넣으면 Preview에서 깔끔하게 렌더링될 거예요.

원하면 제가 이걸 바로 깃허브에 적용 가능하게 **md 파일 형태**로도 드릴까요? 그러면 붙여넣기 없이 업로드만 하면 됩니다.

