

# 운영체제 메모리 관리 개념 정리

---

## 📂 메모리 교체와 스왑

### 🔹 스와핑 (Swapping)

* 운영체제가 메모리 부족 상황을 해결하기 위해 프로세스 전체를 메모리에서 디스크로 내보냈다가 다시 불러오는 기법

* 페이지 단위가 아니라 프로세스 단위로 메모리를 교체하는 오래된 방식

* 현대 OS에서는 페이징이 주류라 스와핑은 거의 쓰이지 않지만, 개념적으로는 중요

**특징**

* 전체 프로세스를 디스크 ↔ 메모리로 이동하기 때문에 오버헤드가 크고 느림

* 다만, 메모리가 극도로 부족한 상황에서는 유용할 수 있음

* 스왑 영역(Swap Area)을 사용한다는 점에서는 페이지 교체와 유사하지만, 단위가 다름 (프로세스 vs 페이지)
### 🔹 스왑 아웃 (Swap Out)

* 현재 메모리에 올라와 있는 페이지(또는 프로세스)를 **보조기억장치(디스크)의 스왑 영역으로 내보내는 것**
* 메모리가 부족할 때 불필요하거나 오랫동안 쓰이지 않은 페이지를 쫓아냄

### 🔹 스왑 인 (Swap In)

* 디스크의 스왑 영역에 있던 페이지를 다시 **물리 메모리로 불러오는 것**
* 페이지 폴트 발생 시 자주 수행됨

### 🔹 스왑 영역 (Swap Area)

* 디스크 중에서 **메모리 대체 저장소**로 쓰이는 영역
* RAM보다 느리지만 메모리 부족을 완화하는 역할

---

## 📂 메모리 할당과 단편화

### 🔹 연속 메모리 할당

* 프로세스에 필요한 메모리를 **연속된 공간**에 배치하는 방식
* 구현은 단순하지만, 외부 단편화 문제가 발생하기 쉬움

### 🔹 외부 단편화 (External Fragmentation)

* 메모리 공간 전체는 충분하지만, **군데군데 빈틈이 흩어져 있어서 연속 공간 확보가 불가능**한 상태

### 🔹 내부 단편화 (Internal Fragmentation)

* 운영체제가 일정한 크기 블록 단위로 메모리를 할당했을 때, **블록 내부에 사용되지 못하고 남는 자투리 공간**

---

## 📂 페이징 기법

### 🔹 페이징 (Paging)

* 물리 메모리와 가상 메모리를 \*\*고정 크기 블록(프레임/페이지)\*\*으로 나누어 관리하는 기법
* 외부 단편화 해결, 내부 단편화 가능

### 🔹 페이지 테이블 (Page Table)

* **가상 페이지 번호 ↔ 물리 프레임 번호**를 매핑하는 자료구조
* CPU가 가상주소를 물리주소로 변환할 때 참고

### 🔹 계층적 페이징 (Hierarchical Paging)

* 페이지 테이블 크기가 너무 커질 때, **페이지 테이블을 다시 페이지 단위로 나누어 계층적 관리**
* 2단계, 3단계 페이지 테이블 구조 사용

### 🔹 TLB (Translation Lookaside Buffer)

* 최근 사용된 **가상→물리 주소 변환 정보를 저장하는 캐시**
* CPU 내부(MMU 안)에 존재
* TLB 히트 → 빠른 변환, TLB 미스 → 페이지 테이블 접근

---

## 📂 페이지 테이블 엔트리(PTE)의 주요 비트

### 🔹 유효 비트 (Valid Bit)

* 해당 페이지가 **현재 물리 메모리에 존재하는지 여부** 표시
* 0이면 페이지 폴트 발생

### 🔹 보호 비트 (Protection Bit)

* 페이지 접근 권한(읽기, 쓰기, 실행)을 정의
* 잘못된 접근 시 예외 발생

### 🔹 수정 비트 (Dirty Bit)

* 페이지가 메모리에서 **수정되었는지 여부** 표시
* 1이면 스왑 아웃 시 디스크에 다시 기록해야 함

### 🔹 참조 비트 (Reference Bit)

* CPU가 해당 페이지에 **최근 접근했는지** 기록
* 페이지 교체 알고리즘(LRU, Clock 등)에서 사용

---

## 📂 페이지 폴트와 요구 페이징

### 🔹 페이지 폴트 (Page Fault)

* CPU가 요청한 페이지가 **물리 메모리에 없는 경우** 발생
* 운영체제가 디스크에서 해당 페이지를 불러오고 페이지 테이블 갱신

### 🔹 요구 페이징 (Demand Paging)

* **실제로 필요한 페이지가 접근될 때만** 메모리에 적재하는 기법
* 초기 적재 시간을 줄이고 메모리 효율성 향상

### 🔹 순수 요구 페이징 (Pure Demand Paging)

* **프로세스 실행 시 아무 페이지도 적재하지 않고**, 페이지 폴트가 발생할 때마다 하나씩 불러오는 방식

### 🔹 스래싱 (Thrashing)

* 페이지 교체가 너무 자주 일어나서 CPU가 **실제 계산보다 페이지 스왑 처리에 더 많은 시간**을 소비하는 현상

---

## 📂 페이지 교체 알고리즘

### 🔹 FIFO (First In First Out)

* 메모리에 가장 오래 머문 페이지를 교체
* 단순하지만 성능이 떨어질 수 있음 (Belady의 anomaly 발생 가능)

### 🔹 2차 기회 FIFO (Second-Chance / Clock)

* FIFO에서 교체될 페이지의 **참조 비트**를 확인
* 참조된 적 있으면 비트를 0으로 초기화하고 교체 대상에서 제외 → 기회를 한 번 더 줌

### 🔹 최적 페이지 교체 (Optimal)

* 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체
* 실제로 구현은 불가능, 이론적 기준/비교용 알고리즘

### 🔹 LRU (Least Recently Used)

* 가장 오래 사용되지 않은 페이지를 교체
* 최근 접근 이력을 기준으로 함
* 구현은 스택, 카운터, 참조 비트 등을 활용

---

## 📂 기타

### 🔹 쓰기 시 복사 (Copy-On-Write, COW)

* 프로세스가 메모리를 공유하다가 **실제로 수정하려고 할 때만 복사본을 만드는 방식**
* 초기에는 같은 물리 메모리를 여러 프로세스가 공유 → 효율적 메모리 사용
* 수정이 필요할 때만 별도의 페이지 할당

---
