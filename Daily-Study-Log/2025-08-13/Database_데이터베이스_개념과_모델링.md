# 데이터베이스 개념 정리

## 1. 데이터베이스 개념
**정의**
- 체계적으로 구조화된 데이터 컬렉션을 저장, 관리, 보호하는 디지털 저장소
- 필요할 때 데이터를 효율적으로 검색, 수정, 삭제, 추가할 수 있도록 설계됨

---

## 2. 데이터베이스 구성도
- **데이터**: 저장되는 실제 값 (예: 회원 이름, 전화번호)
- **DBMS**: 데이터베이스를 관리하는 소프트웨어 (예: MySQL, PostgreSQL)
- **사용자**: 데이터를 사용하는 사람 또는 애플리케이션
- **쿼리 언어**: 데이터와 상호작용하는 언어 (SQL 등)

---

## 3. 데이터베이스 필요성
- 데이터 중복 최소화 (중복 저장 방지)
- 데이터 무결성 유지 (정확하고 일관성 있는 데이터)
- 보안 강화 (접근 권한 관리)
- 동시 접근 가능 (여러 사용자가 동시에 사용 가능)
- 백업 및 복구 용이

---

## 4. 파일시스템과 데이터베이스 차이

| 구분 | 파일 시스템 | 데이터베이스 |
|------|-------------|--------------|
| 데이터 접근 | 전체 파일 탐색 | 쿼리로 원하는 데이터만 검색 |
| 데이터 구조 | 구조 정의 없음 | 스키마(구조) 정의 |
| 무결성 | 보장 어려움 | 무결성 제약조건으로 보장 |
| 동시성 | 낮음 | 동시성 제어 지원 |
| 보안 | 제한적 | 사용자/권한별 접근 제어 |

---

## 5. 관계형 DBMS (RDBMS)
- 데이터를 **테이블(표)** 형태로 저장
- **행(Row)** 과 **열(Column)** 구조
- SQL을 사용하여 데이터 관리
- 예: MySQL, PostgreSQL, Oracle, MS SQL Server

---

## 6. 데이터베이스 구성요소
### 1) 테이블(Table)
- 데이터를 행과 열 형태로 저장하는 구조
- 하나의 엔티티(Entity)를 나타냄 (예: 회원 테이블)

### 2) 행(Row, Record)
- 데이터의 한 개 개별 항목
- 예: 한 명의 회원 정보

### 3) 열(Column, Field)
- 데이터 속성(필드) 정의
- 예: 이름, 나이, 전화번호

---

## 7. 데이터베이스 장단점
**장점**
- 데이터 중복 최소화
- 무결성 및 일관성 유지
- 보안성 강화
- 대용량 데이터 관리 용이
- 빠른 검색 및 분석

**단점**
- 초기 구축 비용 높음
- 관리 및 운영에 전문 지식 필요
- DBMS 실행에 따른 성능 부담

---

## 8. 데이터베이스의 종류
- **RDB**: 관계형 데이터베이스 (SQL 기반, 테이블 구조)
- **NoSQL**: 비관계형 DB (문서형, 키-값, 그래프형, 컬럼형 등)
- **Vector DB**: 벡터 임베딩 데이터 저장/검색 특화  
  - 예: Qdrant (AI 검색·추천에 사용)

---

## 9. RDBMS와 NoSQL 차이

| 구분 | RDBMS | NoSQL |
|------|-------|-------|
| 데이터 구조 | 테이블/행/열 | 문서, 키-값, 그래프 등 |
| 스키마 | 고정 스키마 | 유연/무스키마 |
| 확장성 | 수직 확장 중심 | 수평 확장 중심 |
| 트랜잭션 | ACID 보장 | 보장 약함 (대신 성능↑) |
| 예시 | MySQL, Oracle | MongoDB, Redis |

---

## 10. 테이블 설계가 중요한 이유
- 데이터 무결성 보장
- 중복 데이터 방지
- 성능 최적화
- 추후 유지보수 및 확장 용이

---

## 11. 키와 무결성
- **기본 키(Primary Key)**: 행을 고유하게 식별 (중복·NULL 불가)
- **외래 키(Foreign Key)**: 다른 테이블의 기본 키를 참조하여 관계 형성
- **무결성**: 데이터가 정확하고 일관되도록 유지하는 성질
  - 개체 무결성
  - 참조 무결성
  - 도메인 무결성

---

## 12. 기본 키와 외래 키 특징
- **기본 키**: 유일성, NULL 불가, 테이블당 1개
- **외래 키**: 다른 테이블 참조, NULL 가능, 참조 무결성 보장

---

## 13. 좋은 테이블 설계 방법
- 데이터 중복 최소화
- 명확한 키 설정
- 필요한 컬럼만 정의
- 정규화 적용
- 인덱스 적절히 사용

---

## 14. 정규화
- 데이터 구조를 **중복 최소화**하고 **무결성**을 높이기 위한 과정
- 테이블을 더 작은 단위로 나누어 데이터 중복 제거

---

## 15. 주요 정규형
- **1NF**: 원자값만 저장 (컬럼에 여러 값 금지)
- **2NF**: 부분 함수 종속 제거 (기본 키 일부에만 의존 금지)
- **3NF**: 이행적 함수 종속 제거 (키가 아닌 컬럼 간 종속 금지)

---

## 16. 정규화 단계별 조건
- **원자값**: 더 이상 나눌 수 없는 값  
  예: ‘홍길동, 김철수’ → 분리
- **1NF**: 모든 컬럼이 원자값
- **2NF**: 기본 키 전체에 종속
- **3NF**: 키가 아닌 속성은 오직 기본 키에만 종속

---

## 17. 스키마(Schema)
**정의**: 데이터베이스의 구조와 규칙을 정의한 설계도

### 구성 요소
- 테이블 이름
- 컬럼 이름과 데이터 타입
- 기본 키 / 외래 키
- 제약조건 (NOT NULL, UNIQUE, DEFAULT 등)
- 관계 (1:1, 1:N, N:M)

### 종류
- **물리 스키마**: 실제 저장 구조
- **논리 스키마**: 테이블, 컬럼, 관계 등 논리적 구조
- **외부 스키마**: 사용자나 애플리케이션이 보는 DB 뷰

### 예시 (SQL)
```sql
CREATE TABLE Member (
    member_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    join_date DATE DEFAULT CURRENT_DATE
);
````

---

## 18. 3NF 예시와 설명

**문제 있는 테이블**

```
학생_테이블
──────────────────────────────
학번(PK) | 이름     | 학과코드 | 학과이름
──────────────────────────────
202301  | 홍길동   | C01     | 컴퓨터공학
202302  | 김철수   | M01     | 기계공학
```

* 학과이름은 학과코드에 종속 → 이행적 종속 발생

**해결 (3NF 적용)**

```
학생_테이블
────────────────────────
학번(PK) | 이름     | 학과코드
────────────────────────
202301  | 홍길동   | C01
202302  | 김철수   | M01

학과_테이블
────────────────
학과코드(PK) | 학과이름
────────────────
C01         | 컴퓨터공학
M01         | 기계공학
```

* 이제 키가 아닌 속성은 오직 기본 키에만 종속

```

---

```


# 정규화 주의점 & 데이터 모델링 정리

## 1. 정규화 주의할 점
- **과도한 정규화**는 JOIN 연산이 많아져 성능이 떨어질 수 있음
- 실제 서비스에서는 **조회 성능**과 **개발 편의성**도 고려해야 함
- 정규화는 **무조건 3NF 이상**을 지키는 게 목표가 아니라, **업무·성능 균형**이 중요

---

## 2. 반정규화(Denormalization)
- **정규화를 일부러 깨뜨려** 성능을 높이는 설계 방식

**목적**
- 조회 성능 향상
- JOIN 감소

**방법 예시**
1. 자주 JOIN하는 테이블 → 하나로 합침
2. 계산된 컬럼을 미리 저장 (예: 합계, 평균)
3. 코드값을 직접 저장 (참조 테이블 없이)

---

## 3. 잘못 설계된 테이블에서 나타날 수 있는 이상 현상

### 1) 갱신 이상(Update Anomaly)
- 같은 데이터가 여러 곳에 중복 저장되어, 한 곳만 수정하면 불일치 발생
- **예**: 고객 주소가 여러 행에 중복 저장되어, 일부만 변경됨

### 2) 삭제 이상(Delete Anomaly)
- 한 데이터를 삭제했더니, 필요 없는 정보까지 같이 삭제됨
- **예**: 주문 기록 삭제 시 고객 정보까지 사라짐

### 3) 삽입 이상(Insert Anomaly)
- 특정 데이터를 추가하려면 불필요한 값도 넣어야 함
- **예**: 주문이 없으면 고객을 추가할 수 없는 경우

---

## 4. 이상 현상 예시

**문제 있는 테이블**
```

주문\_테이블
────────────────────────────
주문ID | 고객명 | 고객주소    | 상품명
────────────────────────────
O01    | 홍길동 | 서울시 강남구 | 마우스
O02    | 홍길동 | 서울시 강남구 | 키보드

```
- 홍길동 주소가 여러 행에 중복 (**갱신 이상 가능**)
- 홍길동의 모든 주문 삭제 시, 고객 정보도 사라짐 (**삭제 이상 가능**)
- 주문 없이 고객 추가 불가 (**삽입 이상 가능**)

---

## 5. 이상 현상을 해결한 테이블 설계

**정규화 적용**
```

고객\_테이블
────────────────
고객ID(PK) | 고객명 | 고객주소
────────────────
C01        | 홍길동 | 서울시 강남구

주문\_테이블
────────────────
주문ID(PK) | 고객ID | 상품명
────────────────
O01        | C01    | 마우스
O02        | C01    | 키보드

```
- 고객 정보는 한 번만 저장 → 중복 제거
- 주문 삭제해도 고객 정보 유지
- 주문 없어도 고객 등록 가능

---

## 6. 데이터 모델링

**정의**
- 현실 세계의 데이터를 **구조화·시각화**해 표현하는 과정

**목적**
1. 데이터 구조를 명확히 정의
2. 개발자·기획자 간 의사소통 도구
3. DB 설계 및 구현 기반 마련

---

## 7. 데이터 모델링 구성요소 & 활용
- **개체(Entity)**: 저장할 대상 (예: 고객, 주문, 상품)
- **속성(Attribute)**: 개체의 특징 (예: 고객명, 주소)
- **관계(Relationship)**: 개체 간 연결 (예: 고객-주문 = 1:N)

**활용**
- 요구사항 분석 → ERD 작성 → DB 설계 → 구현

---

## 8. 데이터 모델링 순서 절차
1. **업무 파악(요구사항 수집·분석)**  
   - 시스템이 다루는 업무와 데이터 이해

2. **개념적 데이터 모델링**  
   - 개체, 속성, 관계 도출 (업무 중심)

3. **논리적 데이터 모델링**  
   - DBMS 독립적인 구조 설계, 키·제약조건 정의

4. **물리적 데이터 모델링**  
   - 실제 DBMS에 맞게 데이터 타입, 인덱스, 파티션 설정

5. **데이터베이스 구현**  
   - SQL로 테이블 생성 및 제약조건 반영

---

## 9. ERD(Entity Relationship Diagram) 그리기

**Symbol**
- 개체: 네모 박스
- 속성: 타원
- 관계: 마름모
- PK: 밑줄
- 1:N, N:M: 선과 표기

---

## 10. ERD 해석하기

**목표**
- 그림만 보고 개체, 속성, 관계를 파악

**예시**
- 고객(1) — 주문(N) 관계 → 한 고객이 여러 주문 가능
- 주문 — 상품(N:M) → 주문 하나에 여러 상품, 상품 하나가 여러 주문에 포함 가능

---

## 📌 정리
- **정규화**: 데이터 중복 최소화, 무결성 확보
- **반정규화**: 성능 위해 일부러 중복 허용
- **이상 현상**: 잘못된 설계로 데이터 불일치·손실 발생
- **데이터 모델링**: 현실 데이터 → 구조화 → DB 설계
- **ERD**: 데이터 모델링을 시각화한 대표 도구
