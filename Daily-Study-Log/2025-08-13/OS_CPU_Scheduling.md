
---


## 프로세스마다 우선순위가 다르다
운영체제는 CPU 시간을 효율적으로 분배하기 위해 각 프로세스에 **우선순위(priority)**를 부여합니다.
- **pri** : 커널이 내부적으로 사용하는 실제 우선순위 값
- **ni**(nice 값) : 사용자가 설정할 수 있는 우선순위 보정 값 (기본 0, -20 ~ 19 범위)
- 값이 **낮을수록** 높은 우선순위 → 더 빨리 CPU를 얻을 확률이 높음
- `ps -el` 명령어로 pri, ni 확인 가능

---

## 우선순위의 차이를 보이는 대표적인 프로세스 유형
- **I/O Bound** : 디스크/네트워크 같은 입출력 작업이 많음 → CPU 사용시간이 짧고, I/O 대기 시간이 김  
  - 예: 파일 복사, 네트워크 통신
- **CPU Bound** : 연산이 많은 작업 → CPU 사용시간이 김, I/O 요청 적음  
  - 예: 대규모 연산, 동영상 인코딩
- 스케줄러는 이런 성질을 고려해 CPU를 효율적으로 배분함

---

## 스케줄링 큐
프로세스는 실행 상태에 따라 서로 다른 **큐(Queue)**에 위치하게 됩니다.
- **준비 큐(Ready Queue)** : CPU 할당을 기다리는 상태의 프로세스들이 대기
- **대기 큐(Wait Queue / I/O Queue)** : I/O 작업이 끝나기를 기다리는 프로세스들이 대기

---

## 선점형 스케줄링과 비선점형 스케줄링
- **선점형(Preemptive)** : 실행 중인 프로세스를 강제로 중단하고 다른 프로세스에 CPU 할당 가능  
  - 예: 라운드 로빈, SRTF, CFS  
  - 장점: 긴급 작업 대응 가능, 응답 시간 단축  
  - 단점: 컨텍스트 스위칭 오버헤드 증가
- **비선점형(Non-Preemptive)** : 실행 중인 프로세스가 스스로 CPU를 반환할 때까지 기다림  
  - 예: FCFS, SJF(비선점), 우선순위 스케줄링(비선점)  
  - 장점: 구현이 단순, 오버헤드 적음  
  - 단점: 응답 시간이 길어질 수 있음

---

## 오버헤드(Overhead)
- 운영체제가 CPU 스케줄링, 프로세스 전환, 상태 저장/복원 등의 작업을 하면서 소모하는 추가 자원
- 예: 컨텍스트 스위칭, 캐시 초기화, 스케줄링 계산 시간 등
- 선점형 방식에서 더 많이 발생

---

## 전공서 기준 CPU 스케줄링 알고리즘 (7가지)

### 1. 선입 선처리 스케줄링 (FCFS: First Come First Served)
- 준비 큐에 **먼저 들어온 프로세스**부터 처리
- 비선점형 방식
- **호위 효과(Convoy Effect)**: CPU-bound 프로세스가 먼저 오면 뒤에 있는 I/O-bound 프로세스들이 오래 기다림

### 2. 최단 작업 우선 스케줄링 (SJF: Shortest Job First)
- 실행 시간이 짧은 프로세스 먼저 처리
- 평균 대기 시간 최소화 가능
- 실행 시간 예측 필요
- **호위 효과 방지**: CPU-bound 프로세스가 뒤로 밀리면서 I/O-bound 프로세스가 빠르게 처리됨  
  - 단, 실행 시간을 잘못 예측하면 비효율 발생

### 3. 라운드 로빈 스케줄링 (RR: Round Robin)
- 각 프로세스에 동일한 **타임 슬라이스(Time Quantum)**를 할당
- 타임 슬라이스가 끝나면 준비 큐 뒤로 이동
- 공평성 보장, 시분할 시스템에 적합
- 타임 슬라이스가 너무 크면 FCFS처럼, 너무 작으면 오버헤드 증가

### 4. 최소 잔여 시간 우선 스케줄링 (SRTF: Shortest Remaining Time First)
- 선점형 SJF
- 남은 실행 시간이 더 짧은 프로세스가 오면 현재 실행 중인 프로세스 선점
- 평균 대기 시간 최소화 가능
- 단, 잦은 선점으로 오버헤드 증가

### 5. 우선순위 스케줄링 (Priority Scheduling)
- 우선순위가 높은 프로세스부터 실행
- 선점형 또는 비선점형 가능
- **아사 현상(Starvation)**: 낮은 우선순위 프로세스가 계속 대기
- 해결책: **에이징(Aging)** → 대기 시간이 길어질수록 우선순위를 점진적으로 높임

### 6. 다단계 큐 스케줄링 (Multi-level Queue Scheduling)
- 우선순위별로 **여러 개의 큐**를 두고, 각 큐에 다른 스케줄링 알고리즘 적용
- 예: 상위 큐(실시간 프로세스, RR), 하위 큐(백그라운드, FCFS)
- 큐 간 이동 불가 → 아사 현상 발생 가능

### 7. 다단계 피드백 큐 스케줄링 (Multi-level Feedback Queue)
- 다단계 큐에서 **큐 간 이동 가능**
- CPU 사용시간이 길면 하위 큐로, 짧으면 상위 큐로 이동
- 다양한 작업 부하에 대응 가능, 아사 현상 방지

---

## 리눅스 스케줄링 정책
1. **실시간 정책(Real-time Scheduling)**
   - `SCHED_FIFO`: 선입선처리 방식 실시간 스케줄링
   - `SCHED_RR`: 라운드 로빈 방식 실시간 스케줄링

2. **일반 정책(Normal Scheduling)**
   - CFS(Completely Fair Scheduler) 사용
   - 모든 프로세스가 CPU를 공정하게 나눠 가지도록 함

---

## CFS (Completely Fair Scheduler)
- 리눅스의 기본 일반 스케줄러
- 각 프로세스의 **vruntime(가상 실행 시간)**을 추적
- vruntime이 가장 작은(=CPU를 덜 쓴) 프로세스를 우선 실행
- 타임 슬라이스: 프로세스 우선순위(nice 값)에 따라 길이 조절

---

## nice 명령어 & renice 명령어
- **nice**: 새 프로세스를 실행할 때 nice 값(우선순위 보정 값) 설정
  ```bash
  nice -n 5 myprogram   # 우선순위 낮춤
  nice -n -10 myprogram # 우선순위 높임

* **renice**: 실행 중인 프로세스의 nice 값 변경

  ```bash
  renice -n 5 -p 1234   # PID 1234 프로세스 우선순위 변경
  ```


