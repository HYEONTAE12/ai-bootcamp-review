## Python 컴파일 과정과 메모리 구조 강의 

### Python 컴파일 과정

- Python 소스코드(.py)는 바이트코드(.pyc)로 컴파일되는 2단계 과정을 거침
- 컴파일된 바이트코드는 `__pycache__` 폴더에 .pyc 확장자로 저장됨
- 캐시 역할을 하여 동일한 코드 재실행 시 컴파일 시간을 절약하고 실행 속도를 향상시킴
- Python Virtual Machine(PVM)은 바이트코드를 한 줄씩 읽고 해석하여 실행
- 바이트코드는 플랫폼 독립적이므로 다양한 환경에서 실행 가능
- `dis` 모듈을 사용하면 바이트코드를 확인할 수 있음

### 컴퓨터 메모리 계층 구조

- 컴퓨터 시스템은 다양한 속도, 용량, 비용을 가진 메모리를 계층적으로 사용
- 계층 구조 (위로 갈수록 빠르고 비싸며 용량이 작음):
    - 레지스터: CPU 내부에 위치, 극소량의 데이터 저장
    - 캐시 메모리(L1, L2, L3): CPU와 RAM 사이에 위치, SRAM 사용
    - 메인 메모리(RAM): 직접 접근 가능한 주 메모리, DRAM 사용, 휘발성
    - 보조 기억장치: 하드디스크, SSD 등, 용량이 크고 비휘발성
- 가상 메모리: 보조 기억장치 일부를 RAM처럼 사용하는 기술, 매우 느림
- 지역성 원리 활용:
    - 시간적 지역성: 최근 접근한 데이터는 곧 다시 접근될 가능성이 높음
    - 공간적 지역성: 특정 데이터 주변의 데이터도 곧 접근될 가능성이 높음

### 메모리 효율성과 제너레이터

- 리스트는 모든 요소를 한 번에 메모리에 적재하여 공간을 많이 차지함
- 제너레이터는 필요할 때마다 값을 하나씩 생성하고 반환하여 메모리 효율적
- `sys.getsizeof()` 함수로 객체의 메모리 크기 확인 가능
- 제너레이터 사용이 권장되는 경우:
    - 데이터셋이 매우 클 때
    - 계산 비용이 큰 시퀀스를 처리할 때
    - 메모리 절약이 중요한 환경에서
    - 제한된 메모리 환경(임베디드 시스템 등)에서
- 대용량 데이터를 다룰 때 제너레이터를 사용하면 메모리 부족 문제를 해결할 수 있음

### 코드 최적화 팁

- 리스트보다 NumPy 배열이 메모리 접근 효율이 더 좋음
- 순차적 메모리 접근이 무작위 접근보다 캐시 효율성에 유리함
- 불필요한 변수는 `del` 키워드로 제거하여 메모리 관리
- GPU 메모리 부족 시 배치 사이즈를 줄이는 것이 해결책
